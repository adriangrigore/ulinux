#!/bin/sh

set -e

log() {
  printf "%s\n" "$1"
}

error() {
  log "ERROR: ${1}"
}

fail() {
  log "FATAL: ${1}"
  exit 1
}

# source: https://www.yaml.sh/

# shellcheck disable=SC2016
YAML_AWK_PARSER='
function raise(msg) { print msg > "/dev/stderr"; if (force_complete) { exit_status = 1; } else { exit 1; };};
function level() { match($0, /^[[:space:]]*/); if (RLENGTH % 2 != 0) { raise("Bad indentation on line "NR". Number of spaces uneven."); }; return RLENGTH / 2;};
function join_stack(depth) { r = sprintf("%"block_level"s",""); gsub(/ /,"-",r); for (i = 0; i <= depth; i++) { r = r "_" stack[i]; }; sub(/^\./, "", r); return r;};
function safe_split(input, output) { split(input, chars, ""); in_quote = 1; acc = ""; count = 0; for (i=0; i <= length(input); i++) { c=chars[i]; if (c=="\"") { in_quote = (in_quote + 1) % 2; }; if (c=="," && in_quote) { output[count++] = acc; acc = ""; } else { acc = acc c; }; }; output[count++] = acc;};
function remove_sur_quotes(target) { sub(/^[[:space:]]*"/, "", target) ; sub(/"[[:space:]]*$/, "", target) ; return target;};
function check_started() { if (started == 0) { raise("Keys must be added before line "NR); };};
/^---/ { if (started==0) { started=1; } else { block_level++; }; next;};
/^[[:space:]]*[^[:space:]]+:/ { started=1; depth=level(); key=$1; sub(/:.*$/, "", key); stack[depth] = key;};
/^[[:space:]]*[^[:space:]]+:[[:space:]]+[^[:space:]]+/ { started=1; depth=level(); val=$0; sub(/^[[:space:]]*[^[:space:]]+:[[:space:]]+/, "", val); val = remove_sur_quotes(val); print join_stack(depth) "=\"" val "\""; next;};
/^[[:space:]]*\-/ { check_started(); depth=level(); stack_key=join_stack(depth-1); indx=list_counter[stack_key]++; stack[depth]=indx ;};
/^[[:space:]]*-[[:space:]]+\{.*\}[[:space:]]*$/ { check_started(); line=$0; sub(/^[[:space:]]*-[[:space:]]+\{/, "", line); sub(/\}[[:space:]]*$/, "", line); safe_split(line, entries); for (i in entries) { key=entries[i]; val=entries[i]; sub(/^[[:space:]]*/, "", key); sub(/:.*$/, "", key); sub(/^[[:space:]]*[^[:space:]]+:[[:space:]]+"?/, "", val) ; sub(/"?[[:space:]]*$/, "", val) ; val = remove_sur_quotes(val); print join_stack(depth) "_" key "=\"" val "\""; }; delete entries; next;};
/^[[:space:]]*-[[:space:]][^[:space:]]+:/ { check_started(); depth++; key=$0; sub(/^[[:space:]]*-[[:space:]]/, "", key); sub(/:.*$/, "", key); stack[depth]=key;};
/^[[:space:]]*-[[:space:]][^[:space:]]+:[[:space:]]+[^[:space:]]+/ { check_started(); val=$0; sub(/^[[:space:]]*-[[:space:]][^[:space:]]+:[[:space:]]+/, "", val); val = remove_sur_quotes(val); print join_stack(depth) "=\"" val "\""; next;};
/^[[:space:]]*-[[:space:]]+[^[:space:]]+/ { check_started(); val=$0; sub(/^[[:space:]]*-[[:space:]]+/, "", val); sub(/[[:space:]]*$/, "", val); val = remove_sur_quotes(val); print join_stack(depth) "=\"" val "\""; next;};
/^[[:space:]]*[^[:space:]]+:[[:space:]]*$/ {next};
/^[[:space:]]*-[[:space:]]+[^[:space:]]+:[[:space:]]*$/ {next};
/^[[:space:]]*$/ { next };
0
'

parse_yaml() {
  awk "${YAML_AWK_PARSER}" "${1}"
}

netmask2cidr() {
  bits=0
  for octet in $(echo "$1" | sed 's/\./ /g'); do
    binbits=$(echo "obase=2; ibase=10; ${octet}" | bc | sed 's/0//g')
    bits=$((bits + ${#binbits}))
  done
  printf "%d" "${bits}"
}

networkconfig() {
  cfg="$(mktemp -t network-config-XXXXXX)"

  parse_yaml "$1" > "$cfg"

  dev="$(grep "0_name" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//')"
  type="$(grep "0_0_type" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//')"
  addr="$(grep "0_0_address" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//' | sed -e "s/^'//" -e "s/'$//")"
  mask="$(netmask2cidr "$(grep "0_0_netmask" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//' | sed -e "s/^'//" -e "s/'$//")")"
  gw="$(grep "0_0_gateway" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//' | sed -e "s/^'//" -e "s/'$//")"

  ns1="$(grep "__1_0" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//' | sed -e "s/^'//" -e "s/'$//")"
  domain="$(grep "__1_1" "$cfg" | cut -f 2 -d '=' | sed -e 's/^"//' -e 's/"$//' | sed -e "s/^'//" -e "s/'$//")"

  rm -rf "$cfg"

  if [ "$type" = "dhcp" ]; then
    cat > /etc/default/net << EOF
# Auto Generated by network-config
TYPE="dhcp"
DEV="$DEVICE"
EOF
  else
    cat > /etc/default/net << EOF
# Auto Generated by network-config
TYPE="static"
DEV="$dev"
ADDR="$addr"
MASK="$mask"
GW="$gw"
EOF
  fi

  if [ -n "$ns1" ]; then
    cat > /etc/resolv.conf << EOF
# Auto Generated by network-config
nameserver $ns1
EOF
    if [ -n "$domain" ]; then
      echo "search $domain" >> /etc/resolv.conf
    fi
  fi

  # Restart networking
  svc -r net
}

# Retreive contextualization information
CS="$(mktemp -d -t "cloud-config-XXXXXX")"
NS="$(mktemp -d -t "network-config-XXXXXX")"
rm -rf "$CS" "$NS"

# Cleanup
cleanup() {
  rm -rf "$CS" "$NS"
}

trap cleanup EXIT

# ConfigDrive
printf "Trying OpenNebula and ConfigDrive datasources ... "
mkdir -p "$CS".rom
blkid | grep 'TYPE="iso9660"' | awk -F ':' '{ print $1 }' | while read -r name; do
  mount -o ro -t iso9660 "$name" "$CS".rom
  if [ -f "$CS".rom/context.sh ]; then
    sed -n "s|^ *USER_DATA *= *[\"']*\(.*\)[\"']$|\1|p" "$CS".rom/context.sh > "$CS"
  fi
  if [ -f "$CS".rom/ec2/latest/user-data ]; then
    cp "$CS".rom/ec2/latest/user-data "$CS"
  elif [ -f "$CS".rom/user-data ]; then
    cp "$CS".rom/user-data "$CS"
  elif [ -f "$CS".rom/openstack/latest/user-data ]; then
    cp "$CS".rom/openstack/latest/user-data "$CS"
  fi

  if [ -f "$CS".rom/network-config ]; then
    cp "$CS".rom/network-config "$NS"
  fi

  umount "$CS".rom
done
rmdir "$CS".rom
if [ -f "$CS" ]; then
  printf "OK\n"
else
  printf "ERR\n"
fi

if [ ! -f "$CS" ]; then
  # Amazon EC2
  printf "Trying Amazon EC2 datasource ... "
  if ! wget -q -T 5 -O "$CS" http://169.254.169.254/latest/user-data > /dev/null 2>&1; then
    printf "ERR\n"
  fi

  if [ -f "$CS" ]; then
    printf "OK\n"
  else
    printf "ERR\n"
  fi
fi

if [ -s "$NS" ]; then
  if ! networkconfig "$NS"; then
    log "error configuring network"
  fi
fi

# If user data is not provided, nothing to be done
if [ ! -s "$CS" ]; then
  log "Cannot find any userdata or userdata is empty. Nothing to do..."
  exit 0
fi

# Decode user data (if not already decoded)
if [ "$(head -c 12 "$CS")" = "Content-Type" ] || [ "$(head -c 1 "$CS")" != "#" ]; then
  log "Data source seems to be encoded in base64. I will decode it."
  base64 -d "$CS" > "$CS".new
  mv "$CS".new "$CS"
fi

# Parse MIME encoding if present
BOUNDARY=$(head -1 "$CS" | sed -n "s|^Content-Type: *multipart/mixed; *boundary *= *[\"']*\([^\"']*\)[\"']*$|\1|p")
if [ -n "$BOUNDARY" ]; then
  log "Data source seems to be encoded in MIME format. I will decode it."
  awk -v B="$BOUNDARY" -v F="$CS." '{if($0=="--"B"--"){exit}if($0=="--"B){k=k+1;f=F k;getline;s=1;printf "" > f};if(s==1)print $0 >> f}' "$CS"
  rm -f "$CS"
fi

# Execute contextualization commands
for f in "$CS"*; do
  # Skip content-type (if present)
  if [ "$(head -c 13 "$f")" = "Content-Type:" ]; then
    awk '{if($0==""){s=1;getline;}if(s==1)print $0}' "$f" > "$f".new
    mv "$f".new "$f"
  fi

  # Skip files not containing #
  [ "$(head -c 1 "$f")" = "#" ] || continue

  # Execute contextualization command
  FIRST_LINE="$(head -1 "$f")"
  if [ "$FIRST_LINE" = "#!/bin/sh" ]; then
    # This is a shell script, let's just execute it
    printf "Executing Shell contextualization script ... "
    if sh "$f" > /var/log/cloudinit.log 2>&1; then
      printf "OK\n"
    else
      printf "ERR\n"
    fi
  elif [ "$FIRST_LINE" = "#cloud-config" ]; then
    cloud_config="$(mktemp "cloud_config-XXXXXX")"
    authorized_keys="$(mktemp "authorized_keys-XXXXXX")"
    parse_yaml "$f" > "$cloud_config"
    while IFS= read -r opt; do
      key="$(echo "$opt" | cut -f 1 -d '=')"
      raw="$(echo "$opt" | cut -f 2- -d '=')"
      val="${raw#\"}"
      val="${val%\"}"
      case "$key" in
        _hostname)
          hostname "$val"
          ;;
        _disable_root)
          if [ "$val" = "True" ]; then
            passwd -l root
          fi
          ;;
        _ssh_authorized_keys_*)
          echo "$val" >> "$authorized_keys"
          ;;
        _user)
          user="$val"
          if [ "$val" = "root" ]; then
            home="/root"
          else
            home="/home/$val"
          fi
          ;;
        _password)
          password="$val"
          ;;
        _manage_etc_hosts)
          update_etc_hosts=1
          ;;
        *)
          error "Unsupported cloud-config option ${key#_}"
          ;;
      esac
    done < "$cloud_config"

    if [ -n "$update_etc_hosts" ]; then
      sed -i -e "s/^\(127.0.0.1.*\)/\1	$(hostname)/" /etc/hosts
    fi

    if [ -n "$user" ] && [ -n "$password" ]; then
      echo "${user}:${password}" | chpasswd -e
    fi

    if [ -n "$home" ] && [ -s "$authorized_keys" ]; then
      mkdir -p "$home"/.ssh
      if ! grep -q "$(cat "$authorized_keys")" "$home"/.ssh/authorized_keys; then
        cat "$authorized_keys" >> "$home"/.ssh/authorized_keys
      fi
      rm "$authorized_keys"
    fi
  else
    # Other formats are unsupported
    error "Ignoring script starting with $(head -1 "$f" | head -c 100). Not supported."
  fi
done
